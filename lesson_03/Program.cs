// Сложность алгоритма или время работы алгоритма.

/* Задача 1. Найти элемент в массиве.
Создам массив. Заполню. Найду элемент.
Узнать сколько операция потребуется, чтобы найти элемент в массиве. */

// int[] array = new int[5]; // Завёл массив на 5 элементов
// for (int i = 0; i < 5; i++) // Заполнять будет пользователь.
//     array[i] = Convert.ToInt32(Console.ReadLine());
// Console.WriteLine(string.Join(" ",array));
/* Вывод
10
9 
23
-5
6
10 9 23 -5 6 */

// Console.WriteLine("[" + string.Join(", ",array) + "]"); // Более красивый вывод.
// Как посчитать время работы программы, если мне нужно найти определенный элемент?
// Console.WriteLine(array[3]); // 1. Сложности алгоритма О(1) О - это онатация. т.е. Сложность этого алгоритма = 1.
// Этот алгоритм будет работать за о от одного.
/* Вывод
10
-6
34
0
12
[10, -6, 34, 0, 12]
0  */
/* Задача 2. Найти сумму в массиве. Узнать сколько операция потребуется, чтобы вычислить сумму массива.
[4, 5, 3, 1, 2]
Создам массив, заполню. Найду сумму массива.
*/
// int n = 5; 
// int[] array = new int[n]; 
// for (int i = 0; i < n; i++) 
//     array[i] = Convert.ToInt32(Console.ReadLine());
// Console.WriteLine("[" + string.Join(", ",array) + "]");
// Количество операций будет 5. О(n) - Мне потребуется О от n (количество операций). Сложность алгоритма 5.
// Можно массив отсортировать. Тогда будет [1, 2, 3, 4, 5].
// Сортировка займет время и это будет [1, 2, 3, 4, 5] = О(n* log n)
// (n* log n) - быстрая сортировка (log - основание 2), можно по другому.
// Прослеживается закономерность. ((5 + 1)/ 2) * 5 = О(1) - сумма арифметической прогресси.
// т.е. Сложность алгоритма 1.
// n < n * log(n) + 1 - не всегда использование более сложного алгоритма приводит к более быстрому решению.
// Так простой алгоритм, будет работать быстрее в простой задаче.
// int summa = 0;
// for (int i = 0; i < n; i++)
//     summa += array[i];
// // Сложность алгоритма 5 или О(n)
// Console.WriteLine(summa);
// Пример алгоритма О(n^2) - n в квадрате. Сортировка пузырьком и др

// Задание 3. Выведу таблицу умножения в консоль.
// 1  2  3  4  5 
// 2  4  6  8 10
// 3  6  9 12 15
// 4  8 12 16 20
// 5 10 15 20 25

// int n = Convert.ToInt32(Console.ReadLine());
// for (int i = 1; i <= n; i++)
// {
//    for (int j = 1; j <= n; j++)
//    {
//     Console.Write(i * j);
//     Console.Write("\t");
//    }
//    Console.WriteLine();
// }
// Программа работает О(n^2)
// Как уменьшить время программы?
// Решение. Таблицу можно разделить на 2. Мне достаточно узнать её половину. При условии, что она [n,n].

int n = Convert.ToInt32(Console.ReadLine());
int[,] matrix = new int[n, n];
for (int i = 0; i < n; i++)
{
    for (int j = i; j < n; j++)
    {
        matrix[i, j] = (i + 1) * (j + 1);
        matrix[j, i] = (i + 1) * (j + 1);
    }
    Console.WriteLine();
}
for (int i = 0; i < n; i++)
{
    for (int j = 0; j < n; j++)
    {
        Console.Write(matrix[i,j]);
        Console.Write(" ");
    }
    Console.WriteLine();
}
/* Вывод
1 2 3 
2 4 6 
3 6 9 
Заполнение идет: строка - столбец, строка - столбец и т.д.*/
//  О(n^2 / 2)
// Задача. Как изменить сложность алгоритма, если добавить цикл и будет вводить с кубами, т.е. будет тройная матрица. 

// О(n^3 / 3)

